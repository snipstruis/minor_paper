\section{The Problem}
\begin{multicols}{2}\noindent
  The goal of this paper is to extend Meta-Casanova's typesystem to the point where it can handle monad-transformers.
  To see why, we begin with a brief overview of monadic parsing.
  
  \subsubsection*{Monadic Parsing}
  Parser monads are a useful tool for writing compilers.
  They are not only useful in the lexing stage,
  as they can be used for interpreting intermediate representations.

  The best aspect about monadic parsing is that it is \textit{composable}.
  It is possible to combine multiple parsers into a single parser.
  For example: there might be a parser (\texttt{digit}) that can parse a single digit,
  and a parser combinator (\texttt{repeat}) that can apply a parser multiple times until it fails.
  It is then trivial to combine these into a new parser that parses multiple digits.

  \begin{code}[language=Caml]
  let digits = repeat digit
  \end{code}

  A parser is a function that takes an input stream and a context and returns a result.
  A generic implementation may look like this.

  \begin{code}[language=Caml]
  type Parser<'char,'ctxt,'result> =
    List<'char> * 'ctxt
      -> Result<'char,'ctxt,'result>
  \end{code}
  
  The Result contains ---if the parser was successful--- the value returned by the parser, the modified context, and the new input stream position.
  
  \begin{code}[language=Caml]
  type Result<'char,'ctxt,'result> = 
    | Done  of 'result*List<'char>*'ctxt
    | Error of string
  \end{code}

  \subsubsection*{Monad Transformers}
  It may not be obvious, but the parser monad can be constructed from more primitive monads.
  The input stream and the context are represented as a state-monad, and the result is an either-monad.

  \begin{code}[language=Caml]
  type Parser<'char,'ctxt,'result> =
    State<List<'char>*'ctxt,
          Either<result,'error>>
  \end{code}

  Combining monads by hand is tedious and non-trivial.
  Luckily there is a way to automate the process: monad transformers.\footcite[Chapter~18]{Haskell}

  Monad transformers are \textit{type operators} (type-level functions) that takes a monad, and returns a combined monad.
  For example: if we pass the identity monad to the state monad transformer, we get a state monad.

  \subsubsection*{Towards $F_\omega$}
  In order to have type operators, we need higher-order polymorphism.
  The formal name for a type system that supports higher-order polymorphism, System-F$_\omega$.\footcite[Chapter~30]{Pierce02}
  
  %Now that it is clear why monad-transformers are desirable, let's find out what type system we need to support them.
  %In order to have typeclasses like monads, we need subtyping($\lambda_{<:}$)\footcite[Chapter~15]{Pierce02}.
  %And in order to have type operators, we need higher-order polymorphism ($F_\omega$).\footcite[Chapter~30]{Pierce02}.
  %Combining these two, we get higher-order subtyping ($F^\omega_{<:}$)\footcite[Chapter~31]{Pierce02}.
  %It is this $F^\omega_{<:}$ that we will implement.
  
\end{multicols}
