\begin{abstract}
Meta-Casanova is a functional and declarative language designed for writing compilers. 
It is still a language in development and is only simply-typed.
In this paper, we extend the language with type constructors and a module system to allow greater abstractions like generic monad transformers.
\end{abstract}

\tableofcontents
\pagebreak 

\section{Introduction}
(catchy intro here?)

Because the focus of Meta-Casanova is on writing compilers,
we begin with a brief overview of monadic parsing.
We will discover that parser monads can be constructed from more elementary monads,
and that there is a simple way to combine these monads into a parser monad.
We will then find that we need a stronger typesystem than is supported in Meta-Casanova
and that we need to extend it with Modules and Type Operators.
The rest of the paper will go in detail on the design for this type system.

%contributions: designed and mostly implemented together with Jarno Holstein and Louis van den Burg.

\section{The Problem}
\begin{multicols}{2}
  Parser monads are a useful tool for writing compilers.
  They are not only useful in the lexing stage,
  as they can be used for interpreting intermediate representations.

  The best thing about monadic parsing is that it is \textit{composable}.
  It is possible to combine multiple parsers into a single parser.
  For example: there might be a parser (\texttt{digit}) that can parse a single digit,
  and another (\texttt{repeat}) that can apply a parser multiple times until it fails.
  It is then trivial to combine these into a new parser.
  \begin{lstlisting}[language=Caml]
  (* parses multiple digits *)
  let digits = repeat digit
  \end{lstlisting} 

  A parser is a function that takes an input stream and a context and returns a result.
  A generic implementation may look like this.
  \begin{lstlisting}[language=Caml]
  type Parser<'char,'ctxt,'result> =
    List<'char> * 'ctxt
      -> Result<'char,'ctxt,'result>
  \end{lstlisting}
  
  The Result contains ---if everything went well--- the value returned by the parser, the modified context, and the new input stream position.
  \begin{lstlisting}[language=Caml]
  type Result<'char,'ctxt,'result> = 
    | Done  of 'result*List<'char>*'ctxt
    | Error of string
  \end{lstlisting}

  It may not be obvious, but the parser monad can be constructed from more primitive monads.
  The input stream and the context are represented as state-monads, and the result is an either-monad.
  \begin{lstlisting}[language=Caml]
  type Parser<'char,'ctxt,'result> =
    State<List<'char>,
          State<'ctxt,
                Either<result,'error>>
  \end{lstlisting}

  
  
%  brief overview of parser monads and their advantages. (parser combinators)
%  observation that the parser monad is built out of other monads.
  TODO:
  monad transformers are a way to easily define a parser monad in terms of other monads.
  trying to figure out what type system we need.
  we need subtyping for general monads ($\lambda_{<:}$).
  we require type constructors for monad transformers ($F^\omega_{<:}$).
  added benefits are arbitrary static analysis.
\end{multicols}
\pagebreak
\section{The Idea}
\begin{multicols}{2}
  TODO:
  talk about kinds.
  a way to create kinds (modules).
  a way to define type-level functions(typefuncs).
  show example of monad transformers.
  
  \begin{lstlisting}[caption=A generic monad transformer]
  TypeFunc "Monad" ⇒ (* ⇒ *) ⇒ Module
  Monad 'M ⇒ Module {
    Func 'a → ">>=" → ('a → 'M 'b) → 'M 'b
    Func "return" → 'a → 'M 'a
  }
  \end{lstlisting}
  \begin{lstlisting}[caption=the identity monad]
  TypeAlias "Id" ⇒ * ⇒ *
  Id 'a ⇒ 'a
  
  TypeFunc "id" ⇒ Monad 
  id ⇒ Monad(Id) {
    x >>= k → k x
    return x → x
  }
  \end{lstlisting}
\end{multicols}
