\subsection{Meta-Casanova}
\begin{multicols}{2}\noindent
  Meta-casanova uses a syntax similar to natural deduction.
  A rule is comprised of a line with below it on the left of the arrow the input, and on the right the output.
  Above the line are premises that are executed sequentially.

  TODO: explain matches

  Multiple rules may match at any given time.
  If this happens, the program execution splits into multiple branches.
  Each following one rule.
  If none of the rules match, the branch dies off. 
  
  This branch-and-die paradigm is very useful for writing parsers.
  For example: when a numeric digit is encountered,
  it is unclear whether an integer is being parsed or when a floating point literal is being parsed. 
  In Meta-Casanova, you just write two rules.
  One that matches digits followed by a delimiter,
  and another that matches digits followed by a dot and optionally more digits.

  \subsubsection*{Aliases}
  data/typealias. Allows matching.

  \subsubsection*{Premises}
  everything has premises.

  \begin{code}[caption=A Boolean expression interpreter in Meta-Casanova.]
  Data "TRUE"  → Value
  Data "FALSE" → Value
  
  Func "eval" → Expr → Value
  
  Data Expr → "&" → Expr → Expr
  Data Expr → "|" → Expr → Expr
  
  
  eval a → TRUE
  eval b → res
  #\verb|──────────────────|#
  eval (a&b) → res
  
  
  eval a → FALSE
  #\verb|──────────────────|#
  eval (a&b) → FALSE
  
  
  eval a → TRUE
  #\verb|─────────────────|#
  eval (a|b) → TRUE
  
  
  eval a → FALSE
  eval b → res
  #\verb|────────────────|#
  eval (a|b) → res
  \end{code}
\end{multicols}
