\subsection{Meta-Casanova}
  \begin{code}[caption=A Boolean expression interpreter in Meta-Casanova.]
  Data "TRUE"  → Value
  Data "FALSE" → Value
  
  Func "eval" → Expr → Value
  
  Data Expr → "&" → Expr → Expr
  Data Expr → "|" → Expr → Expr

  Value is Expr
  
  eval a → TRUE
  eval b → res
  #\verb|────────────────|#
  eval (a&b) → res
  
  
  eval a → FALSE
  #\verb|──────────────────|#
  eval (a&b) → FALSE
  
  
  eval a → TRUE
  #\verb|─────────────────|#
  eval (a|b) → TRUE
  
  
  eval a → FALSE
  eval b → res
  #\verb|────────────────|#
  eval (a|b) → res
  \end{code}

  \subsubsection*{Funcs}
  Func declarations specify a new function and its type.
  There is no overloading, functions with the declared name can only be of the declared type.

  \subsubsection*{Rules}
  Meta-Casanova uses a syntax similar to that of natural deduction.
  For each Func declaration, there are one or more rules that define it.
  A rule is comprised of a line with below it on the left of the arrow the input, and on the right the output.
  Above the horizontal line are called \textit{premises}, and are executed sequentially.

  \subsubsection*{Premises}
  The statements above the horizontal line are called \textit{premises}.
  They can be assignments like seen in listing 1, or conditionals like \verb|a=3| or \verb|c<d|.

  Often, a premise can fail.
  When that happens, the the entire rule fails to pattern-match and branch of execution dies.
  With the branch-and-die paradigm, other branches continue.

  \subsubsection*{Matching}
  Meta-Casanova uses pattern-matching to find out what function implementation will be called.

  Multiple rules may match at any given time.
  If this happens, the program execution splits into multiple branches.
  Each following one rule.
  If none of the rules match, the branch dies off. 
  
  This branch-and-die paradigm is very useful for writing parsers\cite{huttonmeijer96}.
  For example: when a numeric digit is encountered,
  it is unclear whether an integer is being parsed or when a floating point literal is being parsed. 
  In Meta-Casanova, you just write two rules.
  One that matches digits followed by a delimiter,
  and another that matches digits followed by a dot and optionally more digits.

  \subsubsection*{Aliases}
  \texttt{Data} declarations declare a two-way \mbox{many-to-1} relation between types.
  This two-way relationships makes \texttt{Data} an \textit{alias}.

  \begin{code}
  Data Expr → "&" → Expr → Expr
  Data Expr → "|" → Expr → Expr
  \end{code}

  Using this excerpt from listing 1 as example, both `\&' and `|' are defined to take two Exprs and return an Expr.
  They specify that a Expr can be constructed in two ways, with an `\&' and a `|'.
  Conversely, they also specify that an Expr can be matched in a rule with `\&' or `|'. 

  Additionally, the ``X is Y'' syntax declares that all valid constructors for type X are valid constructors for type Y, but not vice-versa.

