\subsection{Module Details}
Modules were designed to be as flexible as possible, to allow them to model as great a range of abstractions as possible.
This means minimizing restrictions, and maximizing orthogonality.
This philosophy manifests itself in the following ways:

\subsubsection*{Scope contents}
Scopes mainly consist of \texttt{Func} declarations, but can be used for everything.
They are equivalent to top-level scope\footnote{Except for \texttt{import} statements, those are not allowed in modules.}. 
We choose not to artificially limit the scope to maximize expressivity.

\subsubsection*{Modules declare new kinds}
Simplest solution was to reuse the \texttt{TypeFunc} system for compile-time tasks.
Kinds are a compile-time mechanism, and TypeFuncs are used for all compile-time tasks.

\subsubsection*{Inheritance propegation}
Inherit statements inherit recursively.
If C inherits from B, and B inherits from A, then C inherits both B and A.
This is different from the way imports work.
Import statements don't import recursively.
This is to prevent the namespace getting cluttered with dependencies.

\subsubsection*{Modules can have premises}
'cause why not. (TODO: find simple usecase)

\subsubsection*{Module inheritance vs composition}
monad class; zero class; type monadZero âˆˆ monad, zero.
(TODO: good arguments for inheritance)
